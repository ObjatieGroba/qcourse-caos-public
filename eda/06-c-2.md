
### –°–∏–º–≤–æ–ª—ã –≤–Ω–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ ASCII - Unicode

–í ASCII 127 —Å–∏–º–≤–æ–ª–æ–≤, –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ 1 –±–∞–π—Ç. Unicode - –∫–æ–¥–∏—Ä–æ–≤–∫–∞, –≥–¥–µ –∫–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª –∏–º–µ–µ—Ç –Ω–æ–º–µ—Ä code point.

```python
# python
ord('f')  # 102
chr(1100) # —å
```

–í –∫–∞—á–µ—Å—Ç–≤–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ code points –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–µ–ø–µ—Ä—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º utf-8. –û–Ω–∞
–∑–∞–ø–∏—Ö–∏–≤–∞–µ—Ç –≤—Å–µ —Å–∏–º–≤–æ–ª—ã –≤ –±–∞–π—Ç–æ–≤—É—é —Å—Ç—Ä–æ–∫—É. –°–∏–º–≤–æ–ª—ã ascii –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç—Å—è —Ç–µ–º–∏ –∂–µ
–∫–æ–¥–∞–º–∏. –í–Ω–µ ascii ‚Äî —Ä–∞—Å–ø–∏–ª–∏–º —á–∏—Å–ª–æ –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —É—á–∞—Å—Ç–∫–∏ –±–∏—Ç, —Å—Ç–∞—Ä—à–∏–º–∏ –±–∏—Ç–∞–º–∏
–±—É–¥–µ–º –∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∏—Ö  –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å

```
ùÑû ‚Üê U+1D11E MUSICAL SYMBOL G CLEF
0x1d11e = 0b11101_000100_011110

UTF-8: 0b11110_000 0b10_011101 0b10_000100 0b10_011110
```

```python
In [1]: [bin(b) for b in 'q'.encode('utf-8')]
Out[1]: ['0b01110001']

In [2]: [bin(b) for b in '—è'.encode('utf-8')]
Out[2]: ['0b11010001', '0b10001111']

In [3]: [bin(b) for b in '„ÉÑ'.encode('utf-8')]
Out[3]: ['0b11100011', '0b10000011', '0b10000100']

In [4]: [bin(b) for b in 'ùÑû'.encode('utf-8')]
Out[4]: ['0b11110000', '0b10011101', '0b10000100', '0b10011110']
```

Overlong encoding ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª—å—à–µ–≥–æ —á–∏—Å–ª–∞ –±–∞–π—Ç, —á–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:
`0b110_00000 0b10_100001` ‚Üí —Å–∏–º–≤–æ–ª `chr(0b100001) == '!'`.

[–°—Ç–∞—Ç—å—è –ø—Ä–æ –Æ–Ω–∏–∫–æ–¥](https://tonsky.me/blog/unicode)

## Bits and pieces

–ò–Ω–æ–≥–¥–∞ —Ö–æ—á–µ—Ç—Å—è —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ –±–∏—Ç–∞–º–∏ –≤–Ω—É—Ç—Ä–∏ –∑–Ω–∞—á–µ–Ω–∏—è.

–í—Å–ø–æ–º–Ω–∏–º –∫–æ–¥–∏—Ä–æ–≤–∫—É UTF-8:
```c
0xxxxxxx ‚Äî c–∏–º–≤–æ–ª ASCII
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

–û–ø–µ—Ä–∞—Ç–æ—Ä—ã —Å–¥–≤–∏–≥–∞ —è —è–∑—ã–∫–µ –°–∏:
 ```c
 x << n
 x >> n
 ```

Undefined behaviour, –µ—Å–ª–∏:
> ‚Äî An expression is shifted by a negative number or by an amount greater than or equal to the width of the promoted expression (6.5.7).
> ‚Äî An expression having signed promoted type is left-shifted and either the value of the expression is negative or the result of shifting would be not be representable in the promoted type (6.5.7).

–ù–∞–ø—Ä–∏–º–µ—Ä:
```c
7 << 2           // 28
7 << -1          // UB
7 << 30          // –Ω–∞ –Ω–∞—à–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ UB
-1 >> 1          // implementation defined
0xABCDEFFFu << 4 // 0xBCDEFFF0u
0 << 32          // –Ω–∞ –Ω–∞—à–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ UB
```

–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–±–æ–≤–∞—Ç—å –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –±–∞–π—Ç—ã –∏–∑ UTF-8:
```c
_Bool is_ascii(char b) {
    // return (b >> 7) == 0; // nope, could be signed char
    return ((unsigned char) b >> 7) == 0;
}

_Bool is_continuation(unsigned char b) {
    // return (b >> 6) == 0b10; // valid in C++14
    return (b >> 6) == 2;
}

_Bool is_2_byte_start(unsigned char b) {
    return (b >> 5) == 6; // 0b110
}
```

–í–º–µ—Å—Ç–æ —Å–¥–≤–∏–≥–æ–≤ –º–æ–∂–Ω–æ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–∏—Ç–æ–≤—ã–º–∏ –º–∞—Å–∫–∞–º–∏:
```c
_Bool is_2_byte_start(unsigned char b) {
    return (b & 0xE0) == 0xC0; // 0b1110'0000, 0b1100'0000
}
```

–ë–∏—Ç–æ–≤—ã–µ –ø–æ–ª—è:
```c
struct u8char {
    uint8_t sign_bit : 1;
    uint8_t tail_bits : 7;
}

union char_breaker {
    uint8_t number;
    struct u8char fields;
}

...
union char_breaker cb = {.number = 'x'};
cb.fields.sign_bit; // implementation defined if this is the sign bit :-(
```

## `setjmp` / `longjmp`

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env);
```

## Inline assembly
[–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è GCC](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)
```c
// Basic asm
asm("nop");

// Extended asm
// asm(template : outputs : inputs : clobbers)
```

[–ö–∞–∫–æ–µ-—Ç–æ –∫—Ä–∞—Å–∏–≤–æ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ](https://www.opennet.ru/base/dev/gccasm.txt.html)
```
g - general effective address
m - memory effective address
r - register
i - immediate value, 0..0xffffffff
n - immediate value known at compile time.
    ("i" would allow an address known only at link time)

But there are some i386-specific ones described in the processor-specific
part of the manual and in more detail in GCC's i386.h:

q - byte-addressable register (eax, ebx, ecx, edx)
A - eax or edx
a, b, c, d, S, D - eax, ebx, ecx, edx, esi, edi respectively

I - immediate 0..31
J - immediate 0..63
K - immediate 255
L - immediate 65535
M - immediate 0..3 (shifts that can be done with lea)
N - immediate 0..255 (one-byte immediate value)
```

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã

Declarations and definitions

Translation unit

Extern, static

## –ê–≥—Ä–µ–≥–∞—Ç–Ω—ã–µ —Ç–∏–ø—ã

Arrays and structures

Aggregate initializers

Array dimensions

Pointer arithmetic

Typedef

Alignment

## –î—Ä—É–≥–∏–µ —Ç–µ–º—ã

Hosted vs freestanding

Stdio

Argc/argv

Strings

Restrict

Noreturn etc

VLA

Function pointers

## Typedef and qualifiers

```c
typedef int my_int_32_t;
typedef struct foobar {
    ...
} foobar;

const char *s1, *s2;
const int x = 70;
const char * const msg = "hi";
volatile int counter;
```

## Function pointers

```c
int strcmp(const char *a, const char *b);

// This does not work:
// int *comparator(const char *a, const char *b) = strcmp;

int (*my_comparator)(const char *a, const char *b) = strcmp;

// OK, let's typedef it
typedef int (*comparator_t)(const char *, const char *);

comparator_t comparator = strcmp;

int result1 = (*comparator)("Roger", "David");
int result2 = comparator("Nick", "Rick");

qsort(..., comparator, ...);
```
---
Trying to typedef functions directly does not work
```c
// int (comparator2)(const char *a, const char *b) = strcmp;

typedef int (comparator_t2)(const char *, const char *); // useless

// comparator_t2 comparator2 = strcmp;
// ^ error: function ‚Äòcomparator2‚Äô is initialized like a variable
```

## GCC integer overflow builtins
```c
bool __builtin_add_overflow (type1 a, type2 b, type3 *res);
bool __builtin_sub_overflow (type1 a, type2 b, type3 *res);
bool __builtin_mul_overflow (type1 a, type2 b, type3 *res);

char a = 100, b = 200, c;
int d;
__builtin_add_overflow(a, b, &c);
// -> true == overflow

__builtin_add_overflow(a, b, &d);
// -> false == no overflow
```

## Printing fixed-size types

The problem:
```c
uint32_t var;
printf("%...", var); // ???
printf("%d", var);   // fails on Win16
printf("%ld", var);  // fails on 64-bit systems

scanf("%...", &var); // even worse
```
---
String literal joining
```c
char *longstring = "There is no pain, "
                   "you are receding";
```

–î–ª—è –∫–∞–∂–¥–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –º–∞–∫—Ä–æ—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç —Ä–∞—Å–∫—Ä—ã–≤–∞—Ç—å—Å—è –≤ –Ω—É–∂–Ω—ã–µ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã.
–ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è amd64:
```c
#define PRId32 "d"
#define PRIu32 "u"
#define PRId64 "ld"
#define PRIu64 "lu"
#define SCNi32 "i"
#define SCNiPTR "li"
```

–¢–∞–∫–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —É–∂–µ —Å–æ–±—Ä–∞–Ω—ã –¥–ª—è –Ω–∞—Å –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω–æ–º —Ñ–∞–π–ª–µ inttypes.h:
```c
#include <inttypes.h>

uint32_t var;
uintptr_t ptr;
printf("%" PRId32 "\n", var);
scanf("%" SCNi32 "\n", &var);
scanf("%" SCNiPTR "\n", &ptr);
```

## Dynamic memory

```c
// man malloc
#include <stdlib.h>

// C11, POSIX
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);

// nonstandard
void *reallocarray(void *ptr, size_t nmemb, size_t size);
```

---
```c
enum {buf_size = 20};

char *buf = malloc(buf_size);
// type conversion is automatic
// buf == NULL -> allocation error
// otherwise, contents of buf undefined here

strcpy(buf, "arc de Triomphe");
buf[0] = 'A';
...

free(buf);   // OK
//free(buf); // UB -- double free
buf = NULL;
free(buf);   // OK, free is a no-op here
```
---
```c
int *array = calloc(30, sizeof(*array));
```

Similar to, but not the same thing as:
```c
int *array = malloc(30 * sizeof(*array));
// check for NULL
memset(array, 0, 30 * sizeof(*array));
```
---

```c
// same as malloc(100)
void *ptr = realloc(NULL, 100);

// don't do this
// ptr = realloc(ptr, 200);

void *tmp = realloc(ptr, 200);
if (!tmp) {
    perror("realloc");
    free(ptr);
    return;
} else {
    ptr = tmp;
}
```

---
Dynamic array
```c
struct DynArray {
    size_t size;
    size_t capacity;
    int *ptr;
} array = {};

void append(struct DynArray *arr, int value) {
    if (arr->size + 1 > arr->capacity) {
        size_t newcap = 2 * (arr->capacity + 1);
        int *tmp = realloc(arr->ptr, newcap * sizeof(*tmp));
        if (!tmp) {
            // Handle allocation error
        }
        arr->ptr = tmp;
        arr->capacity = newcap;
    }
    arr->ptr[size++] = value;
}
```
---
Better yet:
```c
int *tmp = reallocarray(arr->ptr, newcap, sizeof(*tmp));
```
Where `reallocarray` is not available:
```c
size_t size;
if (__builtin_mul_overflow(newcap, sizeof(arr->ptr[0]), &size)) {
    // Handle overflow
}
int *tmp = realloc(..., size);
```
---
## Example: delete from list
This won't work:
```c
struct List {
    int data;
    struct List *next;
};

void remove(struct List *list, int key) {
    while (list && list->data != key) {
        list = list->next;
    }
    if (!list) {
        return;
    }
    free(list);
    list = list->next; // use after free
    // no way to update the pointer
}
```
---
```c
struct List {
    int data;
    struct List *next;
};

void remove(struct List **list, int key) {
    while (*list && (*list)->data != key) {
        list = &(*list)->next;
    }
    if (!*list) {
        return;
    }
    struct List *next = (*list)->next;
    free(*list);
    *list = next;
}
```

---
## Example: BST insertion
```c
struct TreeNode {
    int data;

    struct TreeNode *left;
    struct TreeNode *right;
};

int main(void) {
    struct TreeNode *root = NULL;
    ...
}
```
---
```c
struct TreeNode **descend(struct TreeNode **root, int key) {
    while (*root && (*root)->data != key) {
        if ((*root)->data > key) {
            root = &(*root)->left;
        } else {
            root = &(*root)->right;
        }
    }
    return root;
}

void insert(struct TreeNode **root, int key) {
    struct TreeNode **where = descend(root, key);
    if (!*where) {
        *where = calloc(1, sizeof(struct TreeNode));
        ...
        (*where)->data = key;
    }
}
```
---
Sometimes fixed-size buffers are inconvenient:
```c
char buf[100];
// scanf("%s", buf); <- banned
scanf("%99s", buf);
...
snprintf(buf, sizeof(buf), "%d bottles of beer on the wall", 50)
...
fgets(buf, sizeof(buf), stdin);
// gets(buf);  <- banned from C11
```
---
```c
char *buf = NULL;
scanf("%ms", &buf); // POSIX
...
free(buf);
```

```c
char *buf = NULL;
asprintf(&buf,
         "%d little Soldier Boys "
         "went out to dine", 10); // GNU / BSD
...
free(buf);
```
```c
// ssize_t getline(char **lineptr, size_t *n, FILE *stream);
char *line = NULL;
size_t linesize = 0;
getline(&line, &linesize, stdin); // POSIX
...
free(line);
```
---
![w:1000](images/05/ptr-conv1.png)
![w:1000](images/05/ptr-conv2.png)

---
![w:1000](images/05/no-restrict.png)

---
![w:1000](images/05/restrict.png)

---
Strict aliasing
![w:1000](images/05/aliasing.png)

---
Union types
```c
union U {
    uint32_t u;
    char bytes[4];
}

assert(sizeof(union U) == 4);
```
---
Glibc malloc

![w:1000](images/05/glibc-malloc.png)

---
* C++'s `new` uses malloc

* Python: malloc + reference counting + GC

* Go, Java: garbage collection

---
* Overcommit. OOM killer.
* Memory leaks, double free, use after free.
---
Address sanitizer

```bash
gcc -fsanitize=address myprog.c
```

---
Valgrind

```
Valgrind is in essence a virtual machine using just-in-time
(JIT) compilation techniques, including dynamic
recompilation. Nothing from the original program ever gets
run directly on the host processor. Instead, Valgrind first
translates the program into a temporary, simpler form called
Intermediate Representation (IR), which is a
processor-neutral, SSA-based form. ...

...usually, code run with Valgrind ...runs at 20% to 25% of
the speed of the normal program.
```
