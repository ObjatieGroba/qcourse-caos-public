## Операционная система

ПО, которое организует доступ к ресурсам компьютера:
* унифицирует (драйверы, файловая система, ...);
* разделяет (вытесняющая многозадачность, виртуальная память, ...);
* разграничивает (права доступа для пользователей, ...).

Чтобы ОС могла выполнять свои функции, нужна поддержка
со стороны процессора: привилегированный режим,
в котором будет исполняться часть ОС, называемая
*ядром* (kernel).

```
 Прикладные программы

 Системные утилиты

                                       Userspace
────────────────────────────────────────────────────────
                                       Kernelspace
 Ядро ОС                              (привилегированный
                                       режим)
```

## Переносимость и совместимость

API (application programming interface) — контракт на уровне
исходного кода (source-level).

Пример — API стандартной библиотеки языка Си.

ABI (application binary interface) — контракт на уровне
машинного кода и двоичного представления данных:
соглашения о вызовах, способы компоновки,
порядок загрузки и запуска программы,
интерфейс взаимодействия с ядром ОС.

## Семейство юниксовых
Картинка из Википедии:
![](https://upload.wikimedia.org/wikipedia/commons/c/cd/Unix_timeline.en.svg)

В 70-х Кен Tомпсон и Деннис Ричи разработали ОС Research UNIX. В 80-е AT&T ее
коммерциализировала. В это же время Ричард Столлман придумал проект GNU, для
него не хватало ядра. В 90-е Линус Торвальс начал разрабатывать Linux, проект
GNU его подхватил. Теперь мы пользуемся ОС GNU/Linux, название означает OC GNU и
ядро Linux.

Все это развивалось в разных направлениях, переносить программы между разными юниксами было тяжело, были попытки обеспечить переносимость программ между разными юниксами.

В 1985 году компания AT&T специфицировала UNIX System V в документе
[System V Interface Definition (SVID)](https://en.wikipedia.org/wiki/System_V_Interface_Definition).

В 1988 рабочая группа IEEE выпустила первый стандарт POSIX (portable operating system interface), который стандартизировал, что такое UNIX.

[xkcd: How standards proliferate](https://xkcd.com/927/)

1994, X/Open: Single UNIX Specification (SUS).

## Системные вызовы на Linux/amd64

Осуществляются (пока что магической) инструкцией `syscall`.
В регистре `rax` должен быть номер системного вызова,
а в регистрах `rdi`, `rsi`, `rdx`, `r10` (sic), `r8`, `r9` –
аргументы.

Результат системного вызова возвращается в регистре `rax`.

Механизм системного вызова использует регистры `rcx` и `r11` для
хранения временных данных, так что их содержимое будет утрачено.

Системный вызов через inline assembly:
```
    long long result, arg1, arg2, arg3;
    asm volatile("syscall"
        : "=a"(result)                     // output
        : "a"(SYS_...),                    // input: syscall number (in eax/rax)
          "D"(arg1), "S"(arg2), "d"(arg3)  // inputs: arguments (rdi, rsi, rdx)
        : "rcx", "r11", "memory")          // clobbers
```

Напишем программу `bare.S`, которая делает системный вызов `exit`,
не пользуясь стандартной библиотекой языка Си:
```
{{#rustdoc_include code/bare.S}}
```

Соберём её:
```
gcc -static -nostdlib bare.S -o bare
```

То же самое в виде программы на языке Си:
```
{{#rustdoc_include code/bare.c}}
```

Системные вызовы документированы в секции 2 руководства
(**man**ual), поэтому почитать документацию на системный вызов
exit можно так: `man 2 exit`.

## Файлы
Главная сущность, которую мы будем изучать - файлы, поскольку в unix-подобных
системах почти все ресурсы представлены именно через эту абстракцию.

Файл — последовательность байт, к которой ОС предоставляет
доступ посредством *файловых операций*.

Например:
* файл на диске;
* вывод программы;
* пользовательский ввод;
* бесконечная последовательность случайных байт;
* всё содержимое диска;
* ...


```
    ───────────────────────────
... Mary had a little lamb, its ...
    ───────────────────────────
          ▲
          │ file position

read(1) → "a"
read(5) → "d a l"
read(5) → "ittle"
write(5, " wolf")

    ───────────────────────────
... Mary had a little wolf, its ...
    ───────────────────────────
                          ▲
                          │

lseek(-3, SEEK_CUR)  // move file position 3 bytes to the left

    ───────────────────────────
... Mary had a little wolf, its ...
    ───────────────────────────
                       ▲
                       │
```

Заметим, что системные вызовы write/read/lseek могут не иметь смысла при работе с
конкретным файлом. Например, в файл “пользовательский ввод” нельзя ничего
записать или подвинуть позицию чтения/записи.

Конец файла (EOF):

```
    ─────────────────────────┐
... il sole e l'altre stelle.│
    ─────────────────────────┘
                      ▲
                      │

read(10) → "stelle."
read(10) → ""
write(5, " FIN.")

    ──────────────────────────────┐
... il sole e l'altre stelle. FIN.│
    ──────────────────────────────┘
                                  ▲
                                  │
```

> Q. А как пользователь понимает, где EOF?
> 
> A. EOF - ситуация, она нигде. EOF (end of file) -  это не специальный символ, а ситуация, когда после запроса на считывание байтов считывается 0 байт.

## Файловые дескрипторы

Операции для работы с файлами - это системные вызовы, то есть обращения к ядру.
Чтобы объяснить ядру, c каким из файлов мы хотим работать, нужны идентификаторы.
В качестве идентификаторов выступают файловые дескрипторы — целые числа.

```
               char buf[10];
               int fd = 3;
               read(fd, buf, sizeof(buf));
Userspace
──────────────────────────────────────────
Kernelspace
               0 → keyboard
               1 → display
               2 → display
               3 → somefile.txt
```


* 0 (`STDIN_FILENO`) — standard input
* 1 (`STDOUT_FILENO`) — standard output
* 2 (`STDERR_FILENO`) — standard error output 

У каждого процесса собственная таблица файловых дескрипторов.

## POSIX file API

### Системные вызовы read и write

Обёртки в стандартной библиотеке:
```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count); // ssize_t - знаковый size_t
ssize_t write(int fd, const void *buf, size_t count);
```

- производят чтение/запись с текущей позиции и смещают её вперёд
  на количество считанных/записанных байт
- возвращают количество считанных/записанных байт
  (read возвращает 0, только если достиг конца файла, иначе считывает
  ненулевое количество байт, но не больше запрошенного)
- если произошла ошибка, возвращают -1, а также выставляют специальную переменную `errno`. В `errno` хранится номер последней произошедшей при системных вызовах ошибки

Напишем программу mycat, которая будет читать байты со стандартного входа и
писать их на стандартный выход с помощью системных вызовов.

```c
{{#rustdoc_include code/mycat.c}}
```

Команда strace показывает, какие системные вызовы совершает наша программа. Использовать вот так: `strace ./mycat`

Наш буфер сейчас 1 байт. Если файл очень большой, то программа будет работать
долго, поскольку каждый системный вызов занимает некоторое время. Давайте
увеличим буфер, в который читаем файл.

### Системный вызов **open**

```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

- Если файл удалось открыть, `open` возвращает файловый дескриптор
- Если не удалось, `open` вернет -1, а также выставит номер ошибки в errno

Заметим, что приведены две функции open с разными сигнатурами. Язык С так не умеет, на самом деле функция open принимает произвольное количество параметров.

Напишем программу, которая умеет работать с аргументами командной строки

```c
{{#rustdoc_include code/catfile.c}}
```

## **Флаги**

- Режимы доступа к файлу: O_RDONLY, O_WRONLY и O_RDWR
- O_TRUNC обрезает файл, при открытии он получит размер 0
- O_CREAT создаст файл, если его нет
- O_APPEND установит файловую позицию чтения/записи на конец файла

### **Системный вызов lseek**

```c
off_t lseek(int fd, off_t offset, int whence);
```

*offset* - на сколько байт перемотать относительно точки отсчета

*whence* - точка отсчета:

- `SEEK_SET` - с начала файла
- `SEEK_CUR` - с текущей позиции
- `SEEK_END` - с конца файла

Напишем программу, которая перематывает файл на заданную позицию и там что-то записывает.

```c
{{#rustdoc_include code/binpatch.c}}
```

- Если в пустом файле сдвинуть позицию на 5 байт и записать туда 3 байта, то размер файла станет 8, первые 5 байт заполнятся нулями
- `/dev/stdin` для каждого процесса показывает его стандартный вход, в этом файле нельзя переставить позиции чтения и записи. Если передать этот файл в нашу программу, словим ошибку ESPIPE (illegal seek).


## **Переносимость в языке си**

Если мы хотим, чтобы наши программы были переносимы, то пользоваться вызовами, которые стандартизированы POSIX, нельзя. Поэтому язык С предоставляет стандартизированные способы работы с файлами.

```c
#include <stdio.h>

FILE *fopen(const char *pathname, const char *mode);
```

- при успехе возвращает указатель на структуру FILE
- при ошибке возвращает NULL и выставляет номер ошибки в errno

Заметим, что `mode` передаем как символьную строку, она может принимать следующие значения:

![image8](images/image8.png)

Перенос строки `\n` в UNIX-подобных ОС - это символ с кодом 10, а на Windows перевод строки - это символы CR и LF (коды 13 и 10). Ради переносимости язык C работает с текстовым файлами так, чтобы `\n` превращался в тот символ переноса, что нужен на конкретной платформе. Эту опцию можно отключить, добавив в конце `mode` букву b.

```c
// другие функции библиотеки С для работы с файлами

int fclose(FILE *stream);
int fprintf(FILE *stream, const char *format, ...);
int fseek(FILE *stream, long offset, int whence);
```

Стандартная библиотека языка С создает потоки ввода/вывода буферизованными: данные накапливаются в буфере, пока он не заполнится. Только тогда данные передаются в системный вызов write.

```c
#include <stdio.h> 
#include <unistd.h>

int main() {
    FILE *f = fopen("poem. txt", "w");
    fprintf(f, "some string");
    fprintf(f, " and some other string\n");
    pause();
    fclose(f);
}
```

Если во время выполнения `pause` убить программу, то в файл poem.txt ничего не запишется. Чтобы принудительно очистить буфер, нужно написать `fflush(f)` перед `pause`. Если убрать `pause` и не закрывать файл, то данные все равно окажутся на диске, т.к. когда завершается `main`, стандартная библиотека языка С вызывает функцию `exit`, которая закрывает все потоки ввода и вывода, очищая их буферы.

Но нам не всегда хочется при завершении программы закрывать потоки, поэтому можно самим вызвать системный вызов exit:

```c
syscall(SYS_exit, EXIT_SUCCESS);
```

```c
void _exit(int status); // функция в POSIX. завершает программу, но не сбрасывает буфер
void _Exit(int status); // аналогичная функция в стандартной библиотеке си
```

Бывают потоки, буферизованные построчно. Например, стандартные потоки ввода/вывода. При встрече `\n` они сбрасывают буфер. `stderr`, напротив, не буферизован, благодаря этому сообщения об ошибках появляются сразу.

```c
void setbuf(FILE *stream, char *buf); // для управления буферизацией
void setlinebuf(FILE *stream); // для строчной буферизации
```


# Файловая система

## Иерархическая ФС

* Директории
* Корневая директория
* Особые записи `.` и `..`
* Абсолютные и относительные пути

## ФС на устройстве хранения

* Устройства хранения — блочные

![ext4 disk structure](ext4blocks.jpg)

![ext4 inode data blocks](ext4tree.jpg)

* Монтирование

### **Системный вызов stat**

```c
int stat(const char *pathname, struct stat *statbuf); // stat - структура с информацией о файле
```

![image4](images/image4.png)

Введя в терминал `stat filename`, можем получить информацию о размере файла, количестве блоков в нем, размере одного блока, времени доступа и др.

![image5](images/image5.png)

## **Разные типы файлов**

- Обычные файлы (regular) - последовательности байт
- Директории, в которых лежат другие файлы (в том числе директории)
- Символические ссылки
- Жесткие ссылки
- Каналы (fifo)
- Сокеты
- Блочные устройства. Например, диск, куда можно писать блоками
- Символьные устройства. Например, терминал, куда можно читать и писать по одному символу

**Символическая ссылка** — специальный файл, который содержит путь к другому
файлу. Когда программа открывает символическую ссылку, операционная система
открывает файл по пути, который в ней указан. Если
переименуем файл, на который указывает ссылка, то символическая ссылка не будет
никуда показывать. `ln -s poem.txt poem2.txt` создаст символическую ссылку:

![image6](images/image6.png)

Все файлы на диске имеют номера, записанные в Inode. **Жесткая ссылка**
появляется, когда разные имена файлов указывают на один Inode.
`ln mary.txt poem.txt` создаст жесткую ссылку. mary.txt укажет на тот же Inode, что и
poem.txt, и любые изменения в одном файле приведут к изменениям в другом. Если
удалить один из файлов, то второй файл останется.

На Inode есть reference counter, показывающий, сколько имен ссылаются на это
содержимое. Когда reference counter = 0, ОС удаляет файл. Если открыть файл, то
его reference counter на это время увеличится.

```c
int stat(const char *file_name, struct stat *buf);
int lstat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf); // Для работы с открытым файлом с помощью файлового дескриптора, а не пути
int unlink(const char *pathname); // Удаляет связь с Inode. Если pathname - последнее имя, которое указывало на Inode, то Inode удалится
```

Утилита `stat` дает нам информацию о типе файла. Если в `stat` передать имя
символической ссылки, то вместо нее ОС подставит тот файл, на который указывает
ссылка. Поэтому, чтобы узнать, является ли файл символической ссылкой,
используем вызов `lstat`, который работает как `stat`, но передает информацию о
самой символьной ссылке, не производя замену.

## **Директории**

Познакомимся с системными вызовами для работы с директориями.

```c
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
struct dirent *readdir(DIR *dirp); // возвращает 0, если дошли до конца директории
```

В структуре dirent можно посмотреть inode number, имя, тип файла и др.

![image7](images/image7.png)

> Напишем программу myls, которая отображает содержимое некоторой директории
> 

```c
{{#rustdoc_include code/myls.c}}
```

```c
int link(const char *oldpath, const char *newpath); // делает ссылки
int symlink(const char *target, const char *linkpath); // делает символические ссылки
```

* константа PATH_MAX
* getcwd()
