

## Обращения к памяти
Сохранить значение регистра eax по адресу 0x40100,
а потом загрузить обратно в регистр ebx:
```x86asm
    mov [0x40100], eax
    mov ebx, [0x40100]
```

(При этом мы используем 4 байта по адресам
0x40100, 0x40101, 0x40102, 0x40103.)

Положить в память по адресу 0x40100 4-байтное целое число
0x1543:
```x86asm
    mov dword ptr [0x40100], 0x1543
```

Как правило, мы используем в качестве адресов метки:
```x86asm
    .global main
main:
    mov edi, [rip+x]
    call writei32
    call finish

x:  .int 43
```

Не любой адрес в памяти доступен для чтения и тем более записи:
```x86asm
    .global main
main:
    inc [rip+x]
    call finish

x:  .int 43
```
При попытке исполнения инструкции `inc` операционная система
остановит программу с сообщением «Segmentation fault»,
поскольку эти данные нельзя менять.

## Секции .data и .bss
Любые байты, порождаемые ассемблером,
записываются в одну из *секций* исполняемого
файла. По умолчанию это секция `.text`, в которой
ожидается машинный код и которая недоступна для записи.

Данные можно положить в секцию `.data`:
```x86asm
    inc [rip+x]

    .data
x:  .int 43

    .text
    call finish
```

Обратите внимание, что ассемблер собирает вместе содержимое каждой
из секций: в примере выше инструкция `call` окажется в памяти
(и в исполняемом файле)
сразу после `inc`.

Есть также секция .bss, в которую можно положить только нулевые байты:
```x86asm
    .bss
z:  .int 0
    .int 0
    // .int 83  // would be an error
```

Typical memory layout:
```
           ┌──────────────────┐    Executable file
0x00...0000│//////////////////│   ┌───────────────┐
           │//////////////////│   │ headers       │
           ├──────────────────┤   ├───────────────┤
           │.text   (read and │   │.text          │
           │         execute) │   │               │
      rip─►│                  │   │               │
           │                  │   │               │
           │                  │   │               │
           ├──────────────────┤   ├───────────────┤
           │.data   (read and │   │.data          │
           │         write)   │   │               │
           ├──────────────────┤   └───────────────┘
           │.bss    (read and │
           │         write)   │
           │                  │
           ├──────────────────┤
           │//////////////////│
           │//////////////////│    /// = unmapped region
           │//////////////////│          (inaccessible memory)
           │//////////////////│
           │//////////////////│
           │//////////////////│
      rsp─►│stack             │
           │                  │
           │                  │
           │                  │
           │                  │
           ├──────────────────┤
           │//////////////////│
0xff...ffff│//////////////////│
           └──────────────────┘
```

Бывают read-only данные (например, тексты сообщений программы),
для них есть секция `.rodata`. Эта секция не имеет собственной
директивы, поэтому нужно воспользоваться директивой `.section`:
```x86asm
    .section .rodata
pi_digits:
    .byte 3,1,4,1,5,9,2,6
```
(На практике вместо `.rodata` константные данные часто кладут в `.text`.)

## Endianness

x86 — little endian:
```x86asm
    // 0x40100:  00 00 00 00  00 00 00 00
    mov dword ptr [0x40100], 0xabcdef
    // 0x40100:  ef cd ab 00  00 00 00 00
```
Младший байт по младшему адресу в памяти.

## Расширение

[movzx](https://www.felixcloutier.com/x86/movzx),
[movsx](https://www.felixcloutier.com/x86/movsx).

```x86asm
    movzx edi, al  // zero-extend, расширение нулями
    movsx edi, al  // sign-extend, расширение знаковым битом
    cwd  // convert word to double-word: sign-extend ax to dx:ax
    cdq  // convert double-word to quad-word: sign-extend eax to edx:eax
    cqo  // convert quad-word to octo-word: sign-extend rax to rdx:rax
```

## Умножение и деление

[mul](https://www.felixcloutier.com/x86/mul),
[imul](https://www.felixcloutier.com/x86/imul),
[div](https://www.felixcloutier.com/x86/div),
[idiv](https://www.felixcloutier.com/x86/idiv).

## Разные способы адресации в x86

```x86asm
    mov eax, [rip + x]      // rip-relative адресация: загрузили 4 байта по адресу x
    mov eax, [rip + x + 4]  // загрузили следующие 4 байта

    lea rsi, [rip + x]      // (положили в rsi адрес массива x)
    mov eax, [rsi + 4]      // косвенная адресация

    mov rdi, 17
    // загружаем в eax 18-й элемент массива
    // (адрес которого rsi + rdi*4)
    mov eax, [rsi + rdi*4]

    // делаем то же самое
    mov eax, [rip + x + 17*4]

    .bss
x:  .skip 4 * 100

    .data
x5: .int x + 4*5      // в x5 лежит адрес шестого элемента массива x
```

Общий вид обращения к памяти:

`BREG + IREG*SCALE + OFFSET`

Здесь 
BREG — базовый регистр, IREG — индексный регистр,
умножаемый на SCALE (SCALE может быть 1, 2, 4 или 8),
OFFSET — непосредственно заданное смещение.

RIP-relative адресация поддерживает только OFFSET:
```asmx86
    mov eax, [rip + 10]
    mov eax, [rip + x]   // неудачная нотация, но уж какая есть
```

## Стек
Writable область памяти, которая используется
как стек :-). Стек на x86 растёт *вниз* (от старших адресов к младшим).
На верхушку стека (первый занятый байт) указывает регистр rsp.

Скопировать верхушку стека (первые 8 байт) в регистр `rax`:
```x86asm
    mov rax, [rsp]
```

Для того, чтобы класть данные на стек и выталкивать их оттуда,
есть специальные инструкции:
```x86asm
    push %rax  // то же, что sub rsp, 8; mov [rsp], rax
    pop %rax   // то же, что mov rax, [rsp]; add rsp, 8
```

Инструкция `push` одна из немногих, которые могут обратиться
к двум адресам памяти сразу:
```x86asm
    .data
x:  .quad 1900

    .text
    push [rip + x]  // взять 8 байт из памяти по адресу x
                    // и положить их в стек, то есть тоже в память
```

Можно пользоваться памятью выше `rsp`, если вы знаете,
что там что-то есть. Например, если вы положили в стек
два 64-битных числа, их можно оттуда читать и там изменять:
```x86asm
    push 6
    push 7

    // теперь стек выглядит так:
    //    0700 0000 0000 0000 0600 0000 0000 0000 ...
    //    ↑ rsp

    mov rax, [rsp + 8] // загрузили в rax число 6
    inc qword ptr [rsp]        // теперь на верхушке стека лежит число 8
```

*Ниже* `rsp` можно использовать только ближайшие 128 байт памяти (так называемая «красная зона»):
```
    mov [rsp-8], rax    // OK
    mov [rsp-160], rax  // не ОК, эту память могут неожиданно поменять
```

Инструкция `push rsp` кладёт на стек
то значение `rsp`, которое было до её исполнения
(не уменьшенное на 8).


## Подпрограммы

Когда в ДЗ просят сдать «функцию» или «подпрограмму»:
1) исполнение начинается с метки с именем подпрограммы;
2) метка должна быть `.global`;
3) чтобы вернуть управление в проверяющую программу,
   используйте инструкцию `ret`;
4) можно свободно менять значения регистров rax, rdi, rsi, rdx, rcx, r8–r11;
4) если меняете значения других регистров,
   сохраняйте их в стек и потом восстанавливайте.

Например, если вас просят написать функцию `foobar`,
и вам нужно менять регистры `r12` и `r13`:
```x86asm
    .global foobar
foobar:
    push r12
    push r13
    ... // делаем что просят, можем портить r12 и r13
    pop r13 // восстанавливаем в обратном порядке
    pop r12
    ret
```


## Переход по адресу в регистре

```x86asm
{{#rustdoc_include code/absolute-jump.S}}
```

Или так:
```x86asm
{{#rustdoc_include code/functable.S}}
```

## Выравнивание

Как правило, *лучше*, чтобы многобайтовые
обращения к памяти были *выровнены* (aligned).

```x86asm
    // начало секции лежит по максимально выровненному адресу (кратному 16)
    .byte 1
    .int 1    // эти 4 байта лежат по адресу, не кратному 4

    .balign 4 // byte align: здесь добавит 3 байта нулей
    .int 1    // эти 4 байта лежат по адресу, кратному 4

    .balign 2 // не добавит ничего
    .short 1
```



## Подпрограммы

Мы хотим переиспользовать код — вызывать
одну и ту же последовательность инструкций из разных
точек программы.

```x86asm
double_eax:
    sal eax, 1
    jmp ...  // куда?
    

    ...
    jmp double_eax
    // хотим продолжить исполнение здесь

    ...
    jmp double_eax
    // или здесь
```

Некоторые архитектуры решают это с помощью
специального регистра для адреса возврата.
Если бы такой был в x86, подпрограммы могли бы
выглядеть так:
```x86asm
double_eax:
    sal eax, 1
    jmp return_address_register
    

    ...
    lea return_address_register, [rip + 1f]
    jmp double_eax
1:

    ...
    lea return_address_register, [rip + 1f]
    jmp double_eax
1:
```

Но в x86 принято адрес возврата класть на стек:
```x86asm
double_eax:
    sal eax, 1
    pop rdx         // достаём из стека адрес возврата
    jmp rdx         // и переходим по нему
    

    ...
    lea rax, [rip + ret1]
    push rax        // кладём в стек адрес возврата
                    // (адрес следующей инструкции после jmp)
    jmp double_eax  // и переходим на начало подпрограммы
ret1:

    ...
    lea rax, [rip + ret2]
    push rax
    jmp double_eax
ret2:
```

Для этих операций (вход в подпрограмму и возвращение из неё)
есть специальные инструкции `call` и `ret`:
```x86asm
double_eax:
    sal eax, 1
    ret             // достаём из стека адрес возврата
                    // и переходим по нему
    

    ...
    call double_eax // кладём в стек адрес возврата
                    // (адрес следующей инструкции после call)
                    // и переходим на начало подпрограммы

    ...
    call double_eax
```

В подпрограмме важно соблюдать баланс инструкций
`push` и `pop`, чтобы не промахнуться мимо адреса возврата.

## Соглашения о вызовах

Чтобы разные люди (и компиляторы) могли совместно разрабатывать
подпрограммы, им нужно договориться, как передавать
в подпрограмму параметры, как возвращать результат и какие
регистры подпрограмма не будет портить. Такие договорённости
называются *соглашениями о вызовах* (calling conventions).

Стандартное соглашение на нашей платформе (Linux/x86)
называется [cdecl](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI):
* первые 6 параметров передаются в регистрах
  rdi, rsi, rdx, rcx, r8, r9;
* прочие параметры передаются в стеке, причём лежат в памяти
  «по порядку» (адрес увеличивается вместе с номером аргумента);
* параметры удаляет из стека тот, кто их туда положил
  (то есть вызывающая функция);
* возвращаемое значение в регистре rax
  (а 128-битное — в паре `rdx:rax`);
* callee-saved регистры: rbx, rsp, rbp, r12–r15;
* caller-saved регистры: все остальные;
* перед инструкцией call указатель стека выровнен на 16 байт.

Вооружённые этим знанием, мы теперь можем вызывать функции
на Си и быть ими вызваны:

```x86asm
    // int foobar(int a, int b)

    mov edi, a
    mov esi, b
    call foobar

    // возвращённое значение лежит в %eax
```

```x86asm
    // возможная реализация функции foobar (return a + b)
    .global foobar
foobar:
    // сейчас стек выглядит так: return_address ...
    mov eax, edi
    add eax, esi
    ret
```



## Локальные переменные

Под них мы выделяем место на стеке:
```x86asm
baz:
    sub rsp, 8     // выделили себе 8 байт, в которых неизвестно что
    push 0        // выделили себе ещё 8 байт, в которых 0
    // сейчас стек выглядит так: 0  ?  return_addr ...
```

Чтобы обращаться к локальным переменным через rsp, придётся
помнить, на сколько мы этот rsp сместили:
```x86asm
    mov [rsp + 8], 42
```

## Стековый кадр

Принято при входе в функцию сохранять rsp в регистре
rbp (base pointer), а сам rbp перед этим класть на стек:
```x86asm
quux:
    push rbp
    mov rbp, rsp

    /*
    stack layout:  oldrbp  return_addr ...
                   ↑ rbp
    
    local var 1: [rbp - 8]
    local var 2: [rbp - 16]
    */

    ...

    mov rsp, rbp
    pop rbp
    ret
```

Стековый кадр (stack frame):
```
    │   ...         │
    ├───────────────┤
    │  saved rbp    │ ◄─┐
    │               │   │
    │               │   │
    │               │   │
    │  return addr  │   │
    ├───────────────┤   │
rbp→│  saved rbp    │ ──┘
    │  local1       │
rsp→│  local2       │
    │               │
```

## Текст (не тот, который `.text`, а настоящий)

Кодировка [ASCII](https://en.wikipedia.org/wiki/ASCII#Character_set).
```x86asm
greeting:
    .byte 'H'  // то же, что .byte 0x48
    .byte 'i'  // то же, что .byte 0x69
    .byte ' '
    .ascii "guy"
    .asciz "s"  // то же, что .ascii "s\0"

    .asciz "Hi guys"  // ещё раз та же последовательность байт
```
